-------------------------------------------------------- @RestController Annotation -------------------------------------------------------------------------------------------------
A controller is required because Spring needs a dedicated HTTP entry point to map web requests to application logic while keeping business logic separate from requests.
Is a Controller ALWAYS required?
In Spring MVC / Spring Boot â†’ YES

Why @RestController specifically?

@RestController = @Controller + @ResponseBody

Meaning: It handles web requests AND Automatically converts Java objects â†’ JSON

Without a controller, Spring has no idea:

- Which URL maps to which method
- How to parse request data
- How to build a response

-------------------------------------------------------- @PathVariable Annotation -------------------------------------------------------------------------------------------------

@PathVariable is used in Spring MVC / Spring Boot to extract values from the URL path and map them to method parameters.

@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public User getUserById(@PathVariable int id) {
        return userService.getUserById(id);
    }
}

If variable name â‰  parameter name: This will not work, the variable name and parameter name must be same.
@GetMapping("/{id}")
public User getUser(@PathVariable("id") int userId) {
    ...
}

-------------------------------------------------------- @Data Annotation -------------------------------------------------------------------------------------------------
This annotation is a part of lombok dependency which is a dependency that provides annotations to reduce the boilerplate code 

@Data annotation is a shortcut of the following annotations - 
1. @Getter - It generates the get methods of all entities
2. @Setter - It generates the set methods of all non final entities
3. toString method - @ToString - 
4. equals() and hashcode()methods - @equalsAndHashCode - 
5. @RequiredArgsConstructor - The constructor function that initialises all final variables and all variables marked with @NotNull 



Ex - 
@Data
public class User {
    private String name;
    private final Long id;
}

@Data annotation will generate - 
1. getName & setName methods
2. getId (not setId as id is set as final)
3. toString() method
4. equals() and hashCode() methods
5. Constructor (User(Long id))

But If you are dealing with JPA/ Hibernate entities, it is not always recommended to use @Data annotations because - it automatically create toString and equals and hashCode
methods which might create issues 
Like - usually JPA entities has an id entity which is generated by the databases.
Before saying, if the two entities has same id (null), the JPA might consider then the same obj because to (toequals method)
or worse, can create different hascodes, after saving as ID will not be null anymore. which break things if you are using them as Map keys.

@Data annotation is only good either DTOs or simple classes


------------------------------------------------------- @Autowired Annotation -------------------------------------------------------------------------------------------------

- This annotation is used for dependency injection.
- This annotation automatically injects the required bean into the class without explicitly creating a new obj using new keyword
- This works with  
  - constructor
  - setters 
  - field

Example - 

@Service
public class UserService {

    @Autowired
    private UserRepository UserRepository

    // code
}



-------------------------------------------------------- @RequestMapping Annotation -------------------------------------------------------------------------------------------------
RequestMapping annotation is used to map your HTTP request to the controller methods
This can be applied both at the class level or the method level

1. Class Level - 
The URL passed here will act as the base URL for all the methods in that class

@RestController
@RequestMapping(value="/api/users")
public class UserController {

  @GetMapping / url -? /api/users
  public ResponseEntity<List<User>> fetchAllUsers() {
        return ResponseEntity.ok(userService.fetchAllUsers());
    }

    @GetMapping("/{id}")  // url -> /api/users/{id}
    public ResponseEntity<User> fetchSingleUser(@PathVariable Long id) {
        return userService.fetchSingleUser(id).map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}

2. Method Level - 
 @RequestMapping(value="/api/users", method=ReqRequestMethod.POST)
    public ResponseEntity<String> createUser(@RequestBody User user) {
        userService.addUser(user);
        return ResponseEntity.ok("User added successfully");
    }

RequestMapping can also be used to multiple methods

@RequestMapping(value="/submit", method = { RequestMethod.POST, RequestMethod.PUT })
    public ResponseEntity<String> createUser(@RequestBody User user) {
        userService.addUser(user);
        return ResponseEntity.ok("User added successfully");
    }

@GetMapping, @PostMapping etc are just shortcuts for the  
@RequestMapping(value="/api/users", method=RequestMethod.GET), 
@RequestMapping(value="/api/users", method=RequestMethod.POST)


-------------------------------------------------------- @ID Annotation -------------------------------------------------------------------------------------------------

This annotation is used to define the primary key for an entity. Without this JPA won't be able to understand which is the unique identifier for the row.

@Entity
class User {

    @Id 
    private Long id; // This becomes the primary key for the user class
    private String firstName;
    private String lastName;

}

-------------------------------------------------------- @GeneratedValue Annotation -------------------------------------------------------------------------------------------------
This annotation is used with @Id to define how to generate the unique identifier.
Instead of manually creating the ID, hiberate (DB) will do it for you.
Ex- 
@Id
@GeneratedValue(strategy = GENERATION_TYPE.AUTO)
private Long id;

There are multiple strategies - 
1. GENERATION_TYPE.AUTO (default) - DB automatically chooses the correct strategy for you and apply it. This is flexible but not consistent across databases
2. GENERATION_TYPE.IDENTITY - 
 - Hiberate uses the auto increment strategy to generate the primary key values.
 - How this works, it first inserts the value in the DB and then make a call to fetch the generated ID. So, Hiberate will not know the ID in advance. Hence, batch inserts are not effective.
  insert first -> fetch later
 - 
3. GENERATION_TYPE.SEQUENCE - 
- Hiberate uses a special sequence object to generate the values.
- This is an independent object 
- How this works -> Hiberate generate the sequence id, then insert the value using that id. 
- So, Id is know in advance. Hence, batch insertion is effective.

4. GENERATION_TYPE.TABLE - This is very rarely used and it uses the special table to generate IDs


-------------------------------------------------------- @OneToOne Annotation -------------------------------------------------------------------------------------------------

- This defines the one to one relationship between two entities.
Example: A user can have only one address and each address will belong to only one user

@Entity
public class User {

  @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
  @JoinColumn(name="address_id", referencedColumnName="id")
  private Address address
}

CascadeType = CascadeType.ALL
Defines what happens to the child entity when something happens to the parent entity.

CascadeType.ALL â†’ any operation (persist, merge, remove, refresh, detach) done on User is also applied to Profile.

Example:

userRepository.save(user); // saves both User and Profile
userRepository.delete(user); // deletes both User and Profile

3. orphanRemoval

Tells JPA to delete the child entity (Profile) if itâ€™s no longer referenced by the parent (User).

Example:

User user = userRepository.findById(1L).get();
user.setProfile(null);
userRepository.save(user); 
// ðŸš€ orphanRemoval = true â†’ Profile gets deleted from DB automatically


Without orphanRemoval = true, the Profile would just be left in the DB with no parent


-------------------------------------------------------- @ManyToOne Annotation -------------------------------------------------------------------------------------------------

This annotation means that many child entities belong to one parent entity.

ex- @ManyToOne
@JoinColumn(name = "user_id", nullable = false)
private User user;

What this means

Each Cart belongs to one User.
But one User can have many Carts.

Thatâ€™s exactly a Many-to-One relationship:
Many carts â†’ One user

-------------------------------------------------------- @JoinColumn Annotation -------------------------------------------------------------------------------------------------

This annotation tells JPA how to create the foreign key in the DB.

name â†’ the column name in the owning table (User table here).

referencedColumnName â†’ the column in the target table (Profile table here).

@JoinColumn(name = "profile_id", referencedColumnName = "id")

profile_id will be created in the user table.

It will reference the id column of the profile table.

-------------------------------------------------------- @Query Annotation -------------------------------------------------------------------------------------------------
This annotation helps you write custom SQL/JPQL queries in your repository. 

example - @Query("SELECT u from User WHERE u.username = :username")
private findByUsername(@Param("username") String username);

-------------------------------------------------------- @Param Annotation -------------------------------------------------------------------------------------------------
Param annotations bind the method argument with the query placeholder.

example - @Query("SELECT u from User WHERE u.username = :username")
private findByUsername(@Param("username") String username);


-------------------------------------------------------- @Value Annotation -------------------------------------------------------------------------------------------------
This annotation is used to inject the values from - 
1. application.properties file
2. System settings
3. environment variables

1. From application.properties file - 
app.name="My Application"

in your code - 
@Value("${app.name}")
private String appName;


2. You can also provide default values to it - 
@Value("${app.name:"Hello World"}")
private String appName;

3. Inject a System Environment Variable
@Value("${JAVA_HOME}")
private String javaHome;

Precedence (Highest to Lowest) - 
1. Command-line arguments (java -jar app.jar --server.port=9000)
2. Java system properties (-Dserver.port=8085)
3. OS environment variables (SERVER_PORT=7000)
4. application.properties or application.yml
5. Profile-specific properties (application-dev.properties, application-prod.properties)
6. @PropertySource in code (@PropertySource("classpath:custom.properties"))
7. Default values in @Value annotation (@Value("${app.name:DefaultName}"))
